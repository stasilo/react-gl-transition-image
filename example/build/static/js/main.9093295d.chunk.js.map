{"version":3,"sources":["assets/img/mask.png","../../src/ReactGlTransitionImage/index.jsx","../../src/transitions/mask.glsl.js","../../src/transitions/blobby.glsl.js","../../src/transitions/glitch.glsl.js","App.jsx","../../src/transitions/water.glsl.js","../../src/transitions/blur.glsl.js","../../src/transitions/polka.glsl.js","../../src/transitions/noiseSwirls.glsl.js","../../src/transitions/randomSquares.glsl.js","index.js","assets/img/cat2.png","assets/img/cat3.jpg"],"names":["module","exports","ReactGlTransitionImage","props","ref","mask","transitionSrc","textureUrls","React","reglInstance","canvasRef","image","textures","dimRef","wrapDimensions","useResizeObserver","seed","Math","loadAssetsOn","a","mainImagePromise","Promise","resolve","texturePromises","texture","textureImage","setImageData","textureData","onAssetsLoaded","width","height","src","reglReady","imageData","progress","gl","alpha","antialias","stencil","preserveDrawingBuffer","_regl","setReglReady","regl","imageTexture","data","flipY","formattedTextures","texObj","i","textureResolutions","resObj","drawImage","frag","length","transitionAlpha","vert","attributes","position","uniforms","resolution","imageResolution","blend","enable","func","srcRGB","srcAlpha","dstRGB","dstAlpha","depth","count","setRenderCalls","color","renderCalls","wrapperStyles","style","regularBgStyles","top","left","backgroundImage","backgroundSize","backgroundPosition","className","PropTypes","transition","string","GlFadeInImage","useInView","threshold","triggerOnce","inView","useState","assetsLoaded","setAssetsLoaded","useCallback","active","config","tension","friction","clamp","to","fadeProgress","scale","yPos","animProps","transform","App","Array","map","_","key","cat2Src","cat3Src","maskSrc","ReactDOM","render","document","getElementById"],"mappings":"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","file":"static/js/main.9093295d.chunk.js","sourcesContent":["module.exports = __webpack_public_path__ + \"static/media/mask.4b652f63.png\";","import React from 'react';\nimport PropTypes from 'prop-types';\n\nimport _regl from 'regl';\nimport useResizeObserver from 'use-resize-observer';\n\nimport blobbyTransition from '../transitions/blobby.glsl';\nimport maskTransition from '../transitions/mask.glsl';\n\nconst ReactGlTransitionImage = React.forwardRef((props, ref) => {\n    const {\n        className,\n        src,\n        progress,\n        loadAssetsOn,\n        onAssetsLoaded,\n        style,\n        transition,\n        transitionAlpha,\n        textures,\n        mask,\n    } = props;\n\n    const transitionSrc = mask\n        ? maskTransition\n        : transition;\n\n    const textureUrls = React.useMemo(() => (\n        mask\n            ? [...textures, mask]\n            : textures\n    ), [mask, textures]);\n\n    const reglInstance = React.useRef(null);\n    const canvasRef = React.useRef(null);\n\n    const [reglReady, setReglReady] = React.useState(false);\n    const [renderCalls, setRenderCalls] = React.useState(null);\n    const [imageData, setImageData] = React.useState({\n        image: null,\n        textures: [],\n    });\n\n    const dimRef = React.useRef(null);\n    const wrapDimensions = useResizeObserver({ ref: dimRef });\n\n    const seed = React.useMemo(() => Math.random() * 1000, []);\n\n    // load image & optional texture data\n\n    React.useEffect(() => {\n        if(typeof loadAssetsOn !== 'undefined' && !loadAssetsOn) {\n            return;\n        }\n\n        (async () => {\n            const mainImagePromise = new Promise((resolve) => {\n                const image = new Image();\n                image.onload = () => {\n                    resolve(image);\n                };\n\n                image.src = src;\n            });\n\n            let texturePromises = [];\n            if (textureUrls.length > 0) {\n                texturePromises = textureUrls.map((texture) => new Promise((resolve) => {\n                    const textureImage = new Image();\n                    textureImage.onload = () => {\n                        resolve(textureImage);\n                    };\n\n                    textureImage.src = texture;\n                }));\n            }\n\n            const [image, ...textureData] = await Promise.all([\n                mainImagePromise,\n                ...texturePromises,\n            ]);\n\n            setImageData({\n                image,\n                textures: textureData,\n            });\n\n            onAssetsLoaded({\n                width: image.width,\n                height: image.height\n            });\n        })();\n    }, [src, textureUrls, loadAssetsOn, onAssetsLoaded]);\n\n    // construct regl instance (& webgl context) once progress > 0\n    // (otherwise, having many images, we'll hit the max amount of simultaneous gl contexts)\n\n    React.useEffect(() => {\n        if (reglReady || !imageData.image\n            || progress === 0 || progress >= 1) {\n            return;\n        }\n\n        const gl = canvasRef.current.getContext('webgl', {\n            alpha: true,\n            antialias: true,\n            stencil: false,\n            preserveDrawingBuffer: false,\n        });\n\n        reglInstance.current = _regl({ gl });\n        setReglReady(true);\n    }, [reglReady, imageData, progress]);\n\n    // construct regl draw calls\n\n    React.useEffect(() => {\n        if (!reglReady || !imageData.image) {\n            return;\n        }\n\n        const regl = reglInstance.current;\n\n        const imageTexture = regl.texture({\n            data: imageData.image,\n            flipY: true,\n        });\n\n        const formattedTextures = imageData.textures\n            .reduce((texObj, texture, i) => ({\n                ...texObj,\n                [`textures[${i}]`]: regl.texture({\n                    data: texture,\n                    flipY: true,\n                }),\n            }), {});\n\n        const textureResolutions = imageData.textures\n            .reduce((resObj, texture, i) => ({\n                ...resObj,\n                [`textureResolutions[${i}]`]: [\n                    texture.width,\n                    texture.height,\n                ],\n            }), {});\n\n        const drawImage = regl({\n            frag: `\n                precision highp float;\n\n                uniform sampler2D image;\n                uniform vec2 resolution;\n                uniform vec2 imageResolution;\n                uniform float progress, seed;\n\n                ${imageData.textures.length > 0 ? `\n                    uniform sampler2D textures[${imageData.textures.length}];\n                    uniform vec2 textureResolutions[${imageData.textures.length}];\n                ` : ''}\n\n                varying vec2 uv;\n\n                // draw image using \"background-size: cover\"-ish fill\n                // https://gist.github.com/statico/df64c5d167362ecf7b34fca0b1459a44\n                vec2 convertToCoverUvs(vec2 uv, vec2 imageRes) {\n                    vec2 s = resolution; // screen\n                    vec2 i = imageRes; // image\n\n                    float rs = s.x / s.y;\n                    float ri = i.x / i.y;\n\n                    vec2 new = rs < ri\n                        ? vec2(i.x * s.y / i.y, s.y)\n                        : vec2(s.x, i.y * s.x / i.x);\n\n                    vec2 offset = rs < ri\n                        ? vec2((new.x - s.x) / 2.0, 0.0) / new\n                        : vec2(0.0, (new.y - s.y) / 2.0) / new;\n\n                    vec2 uw = uv * s / new + offset;\n\n                    return uw;\n                }\n\n                vec4 getFromColor(vec2 st) {\n                    return vec4(0.);\n                }\n\n                vec4 getToColor(vec2 uv) {\n                    vec2 uw = convertToCoverUvs(uv, imageResolution);\n                    return texture2D(image, uw);\n                }\n\n                ${transitionSrc}\n\n                void main () {\n                    gl_FragColor = transition(uv);\n                    ${transitionAlpha ? 'gl_FragColor.a = progress;' : ''}\n                }\n            `,\n            vert: `\n                precision highp float;\n\n                attribute vec2 position;\n                uniform vec2 resolution;\n                varying vec2 uv;\n\n                void main () {\n                    uv = 1. - position;\n                    gl_Position = vec4(1.0 - 2.0 * position, 0, 1);\n                }\n            `,\n            attributes: {\n                position: [\n                    -2, 0,\n                    0, -2,\n                    2, 2,\n                ],\n            },\n            uniforms: {\n                progress: regl.prop('progress'),\n                resolution: regl.prop('resolution'),\n                seed,\n                image: imageTexture,\n                imageResolution: [\n                    imageData.image.width,\n                    imageData.image.height,\n                ],\n                ...textureResolutions,\n                ...formattedTextures,\n            },\n            // https://stackoverflow.com/questions/45066688/blending-anti-aliased-circles-with-regl/45071910#45071910\n            blend: {\n                enable: true,\n                func: {\n                    srcRGB: 'src alpha',\n                    srcAlpha: 'src alpha',\n                    dstRGB: 'one minus src alpha',\n                    dstAlpha: 'one minus src alpha',\n                },\n            },\n            depth: { enable: false },\n            count: 3,\n        });\n\n        setRenderCalls({ drawImage });\n    }, [reglReady, imageData, seed, transitionAlpha, transitionSrc]);\n\n    // render\n\n    React.useEffect(() => {\n        if (!reglReady || !renderCalls || progress === 0) {\n            return;\n        }\n\n        const regl = reglInstance.current;\n\n        regl.clear({\n            color: [0, 0, 0, 0],\n            depth: 1,\n        });\n\n        renderCalls.drawImage({\n            progress,\n            resolution: [\n                wrapDimensions.width,\n                wrapDimensions.height,\n            ],\n        });\n\n        if (regl && progress >= 1) {\n            regl.destroy();\n            reglInstance.current = null;\n            setReglReady(false);\n        }\n    }, [reglReady, renderCalls, progress, wrapDimensions]);\n\n    // styles\n\n    const wrapperStyles = {\n        position: 'relative',\n        width: '100%',\n        height: '100%',\n        ...style,\n    };\n\n    const canvasWrapperStyles = {\n        position: 'absolute',\n        top: '0',\n        left: '0',\n        width: '100%',\n        height: '100%',\n    };\n\n    const regularBgStyles = {\n        position: 'absolute',\n        top: '0',\n        left: '0',\n\n        width: '100%',\n        height: '100%',\n\n        backgroundImage: `url('${src}')`,\n        backgroundSize: 'cover',\n        backgroundPosition: 'center',\n    };\n\n    return (\n        <div\n            className={className}\n            style={wrapperStyles}\n            ref={dimRef}\n        >\n            {progress <= 1 && (\n                <div\n                    ref={ref}\n                    style={canvasWrapperStyles}\n                >\n                    <canvas\n                        ref={canvasRef}\n                        width={wrapDimensions.width}\n                        height={wrapDimensions.height}\n                    />\n                </div>\n            )}\n            {progress >= 1 && (\n                <div\n                    style={regularBgStyles}\n                />\n            )}\n        </div>\n    );\n});\n\nReactGlTransitionImage.propTypes = {\n    src: PropTypes.string.isRequired,\n    progress: PropTypes.number.isRequired,\n    loadAssetsOn: PropTypes.bool,\n    onAssetsLoaded: PropTypes.func,\n    className: PropTypes.string,\n    style: PropTypes.objectOf(PropTypes.string),\n    transition: PropTypes.string,\n    transitionAlpha: PropTypes.bool,\n    textures: PropTypes.arrayOf(PropTypes.string),\n    mask: PropTypes.string,\n};\n\nReactGlTransitionImage.defaultProps = {\n    className: '',\n    style: {},\n    onAssetsLoaded: () => {},\n    transition: blobbyTransition,\n    transitionAlpha: false,\n    textures: [],\n    mask: null,\n};\n\nexport default ReactGlTransitionImage;\n","// rand() & noise() from:\n// https://gist.github.com/patriciogonzalezvivo/670c22f3966e662d2f83\n\nexport default `\n    float rand(vec2 n) {\n        return fract(sin(dot(n, vec2(12.9898 + seed, 4.1414))) * 43758.5453);\n    }\n\n    float noise(vec2 p) {\n        vec2 ip = floor(p);\n        vec2 u = fract(p);\n\n        u = u*u*(3.0-2.0*u);\n\n        float res = mix(\n            mix(rand(ip),rand(ip+vec2(1.0,0.0)),u.x),\n            mix(rand(ip+vec2(0.0,1.0)),rand(ip+vec2(1.0,1.0)),u.x),\n            u.y\n        );\n\n        return res*res;\n    }\n\n    vec4 getMaskColor(vec2 uv) {\n        vec2 uw = convertToCoverUvs(uv, textureResolutions[0]);\n        return texture2D(textures[0], uw);\n    }\n\n    vec4 transition(vec2 uv) {\n        vec4 col = getToColor(uv);\n        vec4 maskCol = getMaskColor(uv);\n\n        // white => transparent\n        maskCol.a = (maskCol.r + maskCol.g + maskCol.b)/3.;\n\n        // debug mask\n        // return maskCol;\n\n        return mix(\n            vec4(0.),\n\n            col - ((col*0.1+vec4(vec3(0.1), 0.)) - (maskCol * ((1./progress))))\n                * (1. - (1./progress)) * 4.,\n\n            progress\n        );\n    }\n`;\n","export default `\n    // https://gist.github.com/patriciogonzalezvivo/670c22f3966e662d2f83\n\n    float rand(vec2 n) {\n        return fract(sin(dot(n, vec2(12.9898 + seed, 4.1414))) * 43758.5453);\n    }\n\n    float noise(vec2 p) {\n        vec2 ip = floor(p);\n        vec2 u = fract(p);\n\n        u = u*u*(3.0-2.0*u);\n\n        float res = mix(\n            mix(rand(ip),rand(ip+vec2(1.0,0.0)),u.x),\n            mix(rand(ip+vec2(0.0,1.0)),rand(ip+vec2(1.0,1.0)),u.x),\n            u.y\n        );\n\n        return res*res;\n    }\n\n    vec4 transition(vec2 uv) {\n        vec4 col = getToColor(uv);\n\n        // generate blobby noise mask\n        float mask = pow(smoothstep(0.1, 1., clamp(noise(uv*4.) + noise(uv*3.5), 0.2, 1.)), 2.);\n        vec4 maskCol = vec4(vec3(mask), 1.);\n\n        // white => transparent\n        maskCol.a = (maskCol.r + maskCol.g + maskCol.b)/3.;\n\n        // debug mask\n        // return maskCol;\n\n        return mix(\n            vec4(0.),\n            col - ((col*0.1+vec4(vec3(0.1), 0.)) - (maskCol * ((1./progress))))\n                * (1. - (1./progress)) * 4.,\n            progress\n        );\n    }\n`;\n","// author: Gunnar Roth\n// based on work from natewave\n// adapted by Jakob Stasilowicz\n// license: MIT\n\nexport default `\n    vec4 transition(vec2 p) {\n        vec2 block = floor(p.xy / vec2(16));\n        vec2 uv_noise = block / vec2(64);\n        uv_noise += floor(vec2(progress) * vec2(1200.0, 3500.0)) / vec2(64);\n        vec2 dist = progress > 0.0 ? (fract(uv_noise) - 0.5) * 0.3 *(1.0 -progress) : vec2(0.0);\n\n        vec2 red = p + dist * 0.2;\n        vec2 green = p + dist * .3;\n        vec2 blue = p + dist * .5;\n\n        return vec4(\n            getToColor(red).r,\n            getToColor(green).g,\n            getToColor(blue).b,\n            1.0\n        );\n    }\n`;\n","import React from 'react';\n\nimport ReactGlTransitionImage, {\n    glitchTransition,\n    polkaTransition,\n    noiseSwirlsTransition,\n    blurTransition,\n    waterTransition,\n    randomSquaresTransition,\n} from 'react-gl-transition-image';\n\nimport { useInView } from 'react-intersection-observer';\nimport { Spring } from 'react-spring/renderprops';\n\nimport './index.css';\n\nimport cat2Src from './assets/img/cat2.png';\nimport cat3Src from './assets/img/cat3.jpg';\nimport maskSrc from './assets/img/mask.png';\n\nconst GlFadeInImage = ({ src, textures, mask, transition }) => {\n    const [ref, inView] = useInView({\n        threshold: 0,\n        triggerOnce: true\n    });\n\n    const [assetsLoaded, setAssetsLoaded] = React.useState(false);\n    const onAssetsLoaded = React.useCallback(() => setAssetsLoaded(true), [setAssetsLoaded]);\n\n    const active = inView && assetsLoaded;\n\n    return (\n        <div className=\"image\">\n            <Spring\n                config={{\n                    tension: 180,\n                    friction: 45,\n                    clamp: true\n                }}\n                to={{\n                    fadeProgress: active ? 1 : 0,\n                    scale: active ? 1 : 0.9,\n                    yPos: active ? 0 : 80\n                }}\n            >\n                {animProps =>\n                    <ReactGlTransitionImage\n                        ref={ref}\n                        src={src}\n\n                        loadAssetsOn={inView}\n                        onAssetsLoaded={onAssetsLoaded}\n\n                        mask={mask}\n                        textures={textures}\n                        transition={transition}\n\n                        progress={animProps.fadeProgress}\n                        style={{\n                            transform: `scale(${animProps.scale}) translate3d(0, ${animProps.yPos}px, 0)`\n                        }}\n                    />\n                }\n            </Spring>\n        </div>\n    );\n};\n\nconst App = () => {\n    return (\n        <>\n            {[...Array(2)].map((_, i) =>\n                <div\n                    className=\"wrapper\"\n                    key={i}\n                >\n                    <h2>Default transition</h2>\n                    <GlFadeInImage\n                        src={cat2Src}\n                    />\n\n                    <h2>Water</h2>\n                    <GlFadeInImage\n                        src={cat3Src}\n                        transition={waterTransition}\n                    />\n\n                    <h2>Blur</h2>\n                    <GlFadeInImage\n                        src={cat3Src}\n                        transition={blurTransition}\n                    />\n\n                    <h2>Image mask</h2>\n                    <GlFadeInImage\n                        src={cat3Src}\n                        mask={maskSrc}\n                    />\n\n                    <h2>Glitch</h2>\n                    <GlFadeInImage\n                        src={cat2Src}\n                        transition={glitchTransition}\n                    />\n\n                    <h2>Polka</h2>\n                    <GlFadeInImage\n                        src={cat3Src}\n                        transition={polkaTransition}\n                    />\n\n                    <h2>Noise swirl</h2>\n                    <GlFadeInImage\n                        src={cat2Src}\n                        transition={noiseSwirlsTransition}\n                    />\n\n                    <h2>Random squares</h2>\n                    <GlFadeInImage\n                        src={cat2Src}\n                        transition={randomSquaresTransition}\n                    />\n                </div>\n            )}\n        </>\n    );\n}\n\nexport default App;\n","// original author: Paweł Płóciennik\n// adapted by: Jakob Stasilowicz\n// license: MIT\n\nexport default `\n    const float amplitude = 30.;\n    const float speed = 10.;\n\n    vec4 transition(vec2 p) {\n        vec2 dir = p - vec2(.5);\n        float dist = length(dir);\n\n        if (dist > progress) {\n            return vec4(0.);\n        } else {\n            vec2 offset = dir * sin(dist * amplitude - progress * speed);\n            return getToColor( p + (offset * (1. - 1./progress)) );\n        }\n    }\n`;\n","// author: gre\n// license: MIT\n\nexport default `\n    const float intensity = 0.3;\n    const int passes = 6;\n\n    vec4 transition(vec2 uv) {\n        vec4 c1 = vec4(0.0);\n        vec4 c2 = vec4(0.0);\n\n        float disp = intensity*(0.5-distance(0.5, progress));\n        for (int xi=0; xi<passes; xi++) {\n            float x = float(xi) / float(passes) - 0.5;\n            for (int yi=0; yi<passes; yi++) {\n                float y = float(yi) / float(passes) - 0.5;\n                vec2 v = vec2(x,y);\n                float d = disp;\n                c2 += getToColor( uv + d*v);\n            }\n        }\n\n        c2 /= float(passes*passes);\n        return mix(c1, c2, progress);\n    }\n`;\n","// original author: bobylito\n// license: MIT\n\nexport default `\n    const float SQRT_2 = 1.414213562373;\n\n    float dots = 20.0;\n    vec2 center = vec2(0, 0);\n\n    vec4 transition(vec2 uv) {\n        bool nextImage = distance(fract(uv * dots), vec2(0.5, 0.5)) < ( progress / distance(uv, center));\n        return nextImage ? getToColor(uv) : getFromColor(uv);\n    }\n`;\n","// rand() & noise() from:\n// https://gist.github.com/patriciogonzalezvivo/670c22f3966e662d2f83\n\nexport default `\n    float rand(vec2 n) {\n        return fract(sin(dot(n, vec2(12.9898 + seed, 4.1414))) * 43758.5453);\n    }\n\n    float noise(vec2 p){\n        vec2 ip = floor(p);\n        vec2 u = fract(p);\n\n        u = u*u*(3.0-2.0*u);\n\n        float res = mix(\n            mix(rand(ip),rand(ip+vec2(1.0,0.0)),u.x),\n            mix(rand(ip+vec2(0.0,1.0)),rand(ip+vec2(1.0,1.0)),u.x),\n            u.y\n        );\n\n        return res*res;\n    }\n\n    vec4 transition(vec2 uv) {\n        return getToColor(uv + (noise(uv*4.)*(1. - (1./progress))));\n    }\n`;\n","// Author: gre\n// License: MIT\n\nexport default `\n    const ivec2 size = ivec2(10, 10);\n    const float smoothness = 0.5;\n\n    float rand (vec2 co) {\n        return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n    }\n\n    vec4 transition(vec2 p) {\n        float r = rand(floor(vec2(size) * p));\n        float m = smoothstep(0.0, -smoothness, r - (progress * (1.0 + smoothness)));\n        return mix(vec4(0.), getToColor(p), m);\n    }\n`;\n","import './index.css'\n\nimport React from 'react'\nimport ReactDOM from 'react-dom'\nimport App from './App'\n\nReactDOM.render(<App />, document.getElementById('root'))\n","module.exports = __webpack_public_path__ + \"static/media/cat2.03e391d0.png\";","module.exports = __webpack_public_path__ + \"static/media/cat3.70aaec79.jpg\";"],"sourceRoot":""}