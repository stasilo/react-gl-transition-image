{"version":3,"sources":["assets/img/cat3.jpg","../../src/transitions/blobby.glsl.js","../../src/ReactGlTransitionImage/index.jsx","../../src/transitions/mask.glsl.js","../../src/transitions/glitch.glsl.js","App.jsx","../../src/transitions/water.glsl.js","../../src/transitions/polka.glsl.js","index.js","assets/img/cat2.png","assets/img/mask.png"],"names":["module","exports","ReactGlTransitionImage","className","props","src","progress","style","transition","transitionAlpha","textures","mask","transitionSrc","textureUrls","reglInstance","React","canvasRef","reglReady","setReglReady","renderCalls","setRenderCalls","image","imageData","setImageData","dimRef","wrapDimensions","useResizeObserver","ref","seed","Math","mainImagePromise","Promise","resolve","texturePromises","textureImage","textureData","gl","alpha","antialias","stencil","preserveDrawingBuffer","_regl","regl","imageTexture","data","flipY","formattedTextures","textureResolutions","texture","drawImage","frag","vert","attributes","position","uniforms","resolution","imageResolution","blend","enable","func","srcRGB","srcAlpha","dstRGB","dstAlpha","depth","count","color","wrapperStyles","width","height","regularBgStyles","top","left","backgroundImage","backgroundSize","backgroundPosition","PropTypes","string","GlFadeInImage","useInView","threshold","triggerOnce","inView","config","tension","friction","clamp","to","fadeProgress","scale","yPos","animProps","transform","App","Array","map","_","i","key","cat2Src","cat3Src","maskSrc","ReactDOM","render","document","getElementById"],"mappings":"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","file":"static/js/main.4971da98.chunk.js","sourcesContent":["module.exports = __webpack_public_path__ + \"static/media/cat3.70aaec79.jpg\";","export default `\n    // https://gist.github.com/patriciogonzalezvivo/670c22f3966e662d2f83\n\n    float rand(vec2 n) {\n        return fract(sin(dot(n, vec2(12.9898 + seed, 4.1414))) * 43758.5453);\n    }\n\n    float noise(vec2 p) {\n        vec2 ip = floor(p);\n        vec2 u = fract(p);\n\n        u = u*u*(3.0-2.0*u);\n\n        float res = mix(\n            mix(rand(ip),rand(ip+vec2(1.0,0.0)),u.x),\n            mix(rand(ip+vec2(0.0,1.0)),rand(ip+vec2(1.0,1.0)),u.x),\n            u.y\n        );\n\n        return res*res;\n    }\n\n    vec4 transition(vec2 uv) {\n        vec4 col = getToColor(uv);\n\n        // generate blobby noise mask\n        float mask = pow(smoothstep(0.1, 1., clamp(noise(uv*4.) + noise(uv*3.5), 0.2, 1.)), 2.);\n        vec4 maskCol = vec4(vec3(mask), 1.);\n\n        // white => transparent\n        maskCol.a = (maskCol.r + maskCol.g + maskCol.b)/3.;\n\n        // debug mask\n        // return maskCol;\n\n        return mix(\n            vec4(0.),\n            col - ((col*0.1+vec4(vec3(0.1), 0.)) - (maskCol * ((1./progress))))\n                * (1. - (1./progress)) * 4.,\n            progress\n        );\n    }\n`;\n","import React from 'react';\nimport PropTypes from 'prop-types';\n\nimport _regl from 'regl';\nimport useResizeObserver from 'use-resize-observer';\n\nimport blobbyTransition from '../transitions/blobby.glsl';\nimport maskTransition from '../transitions/mask.glsl';\n\nconst ReactGlTransitionImage = React.forwardRef((props, ref) => {\n    const {\n        className,\n        src,\n        progress,\n        style,\n        transition,\n        transitionAlpha,\n        textures,\n        mask,\n    } = props;\n\n    const transitionSrc = mask\n        ? maskTransition\n        : transition;\n\n    const textureUrls = React.useMemo(() => (\n        mask\n            ? [...textures, mask]\n            : textures\n    ), [mask, textures]);\n\n    const reglInstance = React.useRef(null);\n    const canvasRef = React.useRef(null);\n\n    const [reglReady, setReglReady] = React.useState(false);\n    const [renderCalls, setRenderCalls] = React.useState(null);\n    const [imageData, setImageData] = React.useState({\n        image: null,\n        textures: [],\n    });\n\n    const dimRef = React.useRef(null);\n    const wrapDimensions = useResizeObserver({ ref: dimRef });\n\n    const seed = React.useMemo(() => Math.random() * 1000, []);\n\n    // load image & optional texture data\n\n    React.useEffect(() => {\n        (async () => {\n            const mainImagePromise = new Promise((resolve) => {\n                const image = new Image();\n                image.onload = () => {\n                    resolve(image);\n                };\n\n                image.src = src;\n            });\n\n            let texturePromises = [];\n            if (textureUrls.length > 0) {\n                texturePromises = textureUrls.map((texture) => new Promise((resolve) => {\n                    const textureImage = new Image();\n                    textureImage.onload = () => {\n                        resolve(textureImage);\n                    };\n\n                    textureImage.src = texture;\n                }));\n            }\n\n            const [image, ...textureData] = await Promise.all([\n                mainImagePromise,\n                ...texturePromises,\n            ]);\n\n            setImageData({\n                image,\n                textures: textureData,\n            });\n        })();\n    }, [src, textureUrls]);\n\n    // construct regl instance (& webgl context) once progress > 0\n    // (otherwise, having many images, we'll hit the max amount of simultaneous gl contexts)\n\n    React.useEffect(() => {\n        if (reglReady || !imageData.image\n            || progress === 0 || progress >= 1) {\n            return;\n        }\n\n        const gl = canvasRef.current.getContext('webgl', {\n            alpha: true,\n            antialias: true,\n            stencil: false,\n            preserveDrawingBuffer: false,\n        });\n\n        reglInstance.current = _regl({ gl });\n        setReglReady(true);\n    }, [reglReady, imageData, progress]);\n\n    // construct regl draw calls\n\n    React.useEffect(() => {\n        if (!reglReady || !imageData.image) {\n            return;\n        }\n\n        const regl = reglInstance.current;\n\n        const imageTexture = regl.texture({\n            data: imageData.image,\n            flipY: true,\n        });\n\n        const formattedTextures = imageData.textures\n            .reduce((texObj, texture, i) => ({\n                ...texObj,\n                [`textures[${i}]`]: regl.texture({\n                    data: texture,\n                    flipY: true,\n                }),\n            }), {});\n\n        const textureResolutions = imageData.textures\n            .reduce((resObj, texture, i) => ({\n                ...resObj,\n                [`textureResolutions[${i}]`]: [\n                    texture.width,\n                    texture.height,\n                ],\n            }), {});\n\n        const drawImage = regl({\n            frag: `\n                precision highp float;\n\n                uniform sampler2D image;\n                uniform vec2 resolution;\n                uniform vec2 imageResolution;\n                uniform float progress, seed;\n\n                ${imageData.textures.length > 0 ? `\n                    uniform sampler2D textures[${imageData.textures.length}];\n                    uniform vec2 textureResolutions[${imageData.textures.length}];\n                ` : ''}\n\n                varying vec2 uv;\n\n                // draw image using \"background-size: cover\"-ish fill\n                // https://gist.github.com/statico/df64c5d167362ecf7b34fca0b1459a44\n                vec2 convertToCoverUvs(vec2 uv, vec2 imageRes) {\n                    vec2 s = resolution; // screen\n                    vec2 i = imageRes; // image\n\n                    float rs = s.x / s.y;\n                    float ri = i.x / i.y;\n\n                    vec2 new = rs < ri\n                        ? vec2(i.x * s.y / i.y, s.y)\n                        : vec2(s.x, i.y * s.x / i.x);\n\n                    vec2 offset = rs < ri\n                        ? vec2((new.x - s.x) / 2.0, 0.0) / new\n                        : vec2(0.0, (new.y - s.y) / 2.0) / new;\n\n                    vec2 uw = uv * s / new + offset;\n\n                    return uw;\n                }\n\n                vec4 getFromColor(vec2 st) {\n                    return vec4(0.);\n                }\n\n                vec4 getToColor(vec2 uv) {\n                    vec2 uw = convertToCoverUvs(uv, imageResolution);\n                    return texture2D(image, uw);\n                }\n\n                ${transitionSrc}\n\n                void main () {\n                    gl_FragColor = transition(uv);\n                    ${transitionAlpha ? 'gl_FragColor.a = progress;' : ''}\n                }\n            `,\n            vert: `\n                precision highp float;\n\n                attribute vec2 position;\n                uniform vec2 resolution;\n                varying vec2 uv;\n\n                void main () {\n                    uv = 1. - position;\n                    gl_Position = vec4(1.0 - 2.0 * position, 0, 1);\n                }\n            `,\n            attributes: {\n                position: [\n                    -2, 0,\n                    0, -2,\n                    2, 2,\n                ],\n            },\n            uniforms: {\n                progress: regl.prop('progress'),\n                resolution: regl.prop('resolution'),\n                seed,\n                image: imageTexture,\n                imageResolution: [\n                    imageData.image.width,\n                    imageData.image.height,\n                ],\n                ...textureResolutions,\n                ...formattedTextures,\n            },\n            // https://stackoverflow.com/questions/45066688/blending-anti-aliased-circles-with-regl/45071910#45071910\n            blend: {\n                enable: true,\n                func: {\n                    srcRGB: 'src alpha',\n                    srcAlpha: 'src alpha',\n                    dstRGB: 'one minus src alpha',\n                    dstAlpha: 'one minus src alpha',\n                },\n            },\n            depth: { enable: false },\n            count: 3,\n        });\n\n        setRenderCalls({ drawImage });\n    }, [reglReady, imageData, seed, transitionAlpha, transitionSrc]);\n\n    // render\n\n    React.useEffect(() => {\n        if (!reglReady || !renderCalls || progress === 0) {\n            return;\n        }\n\n        const regl = reglInstance.current;\n\n        regl.clear({\n            color: [0, 0, 0, 0],\n            depth: 1,\n        });\n\n        renderCalls.drawImage({\n            progress,\n            resolution: [\n                wrapDimensions.width,\n                wrapDimensions.height,\n            ],\n        });\n\n        if (regl && progress >= 1) {\n            regl.destroy();\n            reglInstance.current = null;\n            setReglReady(false);\n        }\n    }, [reglReady, renderCalls, progress, wrapDimensions]);\n\n    // styles\n\n    const wrapperStyles = {\n        position: 'relative',\n        width: '100%',\n        height: '100%',\n        ...style,\n    };\n\n    const canvasWrapperStyles = {\n        position: 'absolute',\n        top: '0',\n        left: '0',\n        width: '100%',\n        height: '100%',\n    };\n\n    const regularBgStyles = {\n        position: 'absolute',\n        top: '0',\n        left: '0',\n\n        width: '100%',\n        height: '100%',\n\n        backgroundImage: `url('${src}')`,\n        backgroundSize: 'cover',\n        backgroundPosition: 'center',\n    };\n\n    return (\n        <div\n            className={className}\n            style={wrapperStyles}\n            ref={dimRef}\n        >\n            {progress <= 1 && (\n                <div\n                    ref={ref}\n                    style={canvasWrapperStyles}\n                >\n                    <canvas\n                        ref={canvasRef}\n                        width={wrapDimensions.width}\n                        height={wrapDimensions.height}\n                    />\n                </div>\n            )}\n            {progress >= 1 && (\n                <div\n                    style={regularBgStyles}\n                />\n            )}\n        </div>\n    );\n});\n\nReactGlTransitionImage.propTypes = {\n    src: PropTypes.string.isRequired,\n    progress: PropTypes.number.isRequired,\n    className: PropTypes.string,\n    style: PropTypes.objectOf(PropTypes.string),\n    transition: PropTypes.string,\n    transitionAlpha: PropTypes.bool,\n    textures: PropTypes.arrayOf(PropTypes.string),\n    mask: PropTypes.string,\n};\n\nReactGlTransitionImage.defaultProps = {\n    className: '',\n    style: {},\n    transition: blobbyTransition,\n    transitionAlpha: false,\n    textures: [],\n    mask: null,\n};\n\nexport default ReactGlTransitionImage;\n","// rand() & noise() from:\n// https://gist.github.com/patriciogonzalezvivo/670c22f3966e662d2f83\n\nexport default `\n    float rand(vec2 n) {\n        return fract(sin(dot(n, vec2(12.9898 + seed, 4.1414))) * 43758.5453);\n    }\n\n    float noise(vec2 p) {\n        vec2 ip = floor(p);\n        vec2 u = fract(p);\n\n        u = u*u*(3.0-2.0*u);\n\n        float res = mix(\n            mix(rand(ip),rand(ip+vec2(1.0,0.0)),u.x),\n            mix(rand(ip+vec2(0.0,1.0)),rand(ip+vec2(1.0,1.0)),u.x),\n            u.y\n        );\n\n        return res*res;\n    }\n\n    vec4 getMaskColor(vec2 uv) {\n        vec2 uw = convertToCoverUvs(uv, textureResolutions[0]);\n        return texture2D(textures[0], uw);\n    }\n\n    vec4 transition(vec2 uv) {\n        vec4 col = getToColor(uv);\n        vec4 maskCol = getMaskColor(uv);\n\n        // white => transparent\n        maskCol.a = (maskCol.r + maskCol.g + maskCol.b)/3.;\n\n        // debug mask\n        // return maskCol;\n\n        return mix(\n            vec4(0.),\n\n            col - ((col*0.1+vec4(vec3(0.1), 0.)) - (maskCol * ((1./progress))))\n                * (1. - (1./progress)) * 4.,\n\n            progress\n        );\n    }\n`;\n","// author: Gunnar Roth\n// based on work from natewave\n// adapted by Jakob Stasilowicz\n// license: MIT\n\nexport default `\n    vec4 transition(vec2 p) {\n        vec2 block = floor(p.xy / vec2(16));\n        vec2 uv_noise = block / vec2(64);\n        uv_noise += floor(vec2(progress) * vec2(1200.0, 3500.0)) / vec2(64);\n        vec2 dist = progress > 0.0 ? (fract(uv_noise) - 0.5) * 0.3 *(1.0 -progress) : vec2(0.0);\n\n        vec2 red = p + dist * 0.2;\n        vec2 green = p + dist * .3;\n        vec2 blue = p + dist * .5;\n\n        return vec4(\n            getToColor(red).r,\n            getToColor(green).g,\n            getToColor(blue).b,\n            1.0\n        );\n    }\n`;\n","import React from 'react';\n\nimport ReactGlTransitionImage, {\n    glitchTransition,\n    polkaTransition,\n    noiseSwirlsTransition,\n    blurTransition,\n    waterTransition,\n} from 'react-gl-transition-image';\n\nimport { useInView } from 'react-intersection-observer';\nimport { Spring } from 'react-spring/renderprops';\n\nimport './index.css';\n\nimport cat2Src from './assets/img/cat2.png';\nimport cat3Src from './assets/img/cat3.jpg';\nimport maskSrc from './assets/img/mask.png';\n\nconst GlFadeInImage = ({ src, textures, mask, transition }) => {\n    const [ref, inView] = useInView({\n        threshold: 0,\n        triggerOnce: true\n    });\n\n    return (\n        <div className=\"image\">\n            <Spring\n                config={{\n                    tension: 180,\n                    friction: 45,\n                    clamp: true\n                }}\n                to={{\n                    fadeProgress: inView ? 1 : 0,\n                    scale: inView ? 1 : 0.9,\n                    yPos: inView ? 0 : 80\n                }}\n            >\n                {animProps =>\n                    <ReactGlTransitionImage\n                        ref={ref}\n                        src={src}\n\n                        mask={mask}\n                        textures={textures}\n                        transition={transition}\n\n                        progress={animProps.fadeProgress}\n                        style={{\n                            transform: `scale(${animProps.scale}) translate3d(0, ${animProps.yPos}px, 0)`\n                        }}\n                    />\n                }\n            </Spring>\n        </div>\n    );\n};\n\nconst App = () => {\n    return (\n        <>\n            {[...Array(5)].map((_, i) =>\n                <div\n                    className=\"wrapper\"\n                    key={i}\n                >\n                    <h2>Default transition</h2>\n                    <GlFadeInImage\n                        src={cat2Src}\n                    />\n\n                    <h2>Water</h2>\n                    <GlFadeInImage\n                        src={cat3Src}\n                        transition={waterTransition}\n                    />\n\n                    <h2>Blur</h2>\n                    <GlFadeInImage\n                        src={cat3Src}\n                        transition={blurTransition}\n                    />\n\n                    <h2>Image mask</h2>\n                    <GlFadeInImage\n                        src={cat3Src}\n                        mask={maskSrc}\n                    />\n\n                    <h2>Glitch</h2>\n                    <GlFadeInImage\n                        src={cat2Src}\n                        transition={glitchTransition}\n                    />\n\n                    <h2>Polka</h2>\n                    <GlFadeInImage\n                        src={cat3Src}\n                        transition={polkaTransition}\n                    />\n\n                    <h2>Noise swirl</h2>\n                    <GlFadeInImage\n                        src={cat2Src}\n                        transition={noiseSwirlsTransition}\n                    />\n                </div>\n            )}\n        </>\n    );\n}\n\nexport default App;\n","// original author: Paweł Płóciennik\n// adapted by: Jakob Stasilowicz\n// license: MIT\n\nexport default `\n    const float amplitude = 30.;\n    const float speed = 10.;\n\n    vec4 transition(vec2 p) {\n        vec2 dir = p - vec2(.5);\n        float dist = length(dir);\n\n        if (dist > progress) {\n            return vec4(0.);\n        } else {\n            vec2 offset = dir * sin(dist * amplitude - progress * speed);\n            return getToColor( p + (offset * (1. - 1./progress)) );\n        }\n    }\n`;\n","// original author: bobylito\n// license: MIT\n\nexport default `\n    const float SQRT_2 = 1.414213562373;\n\n    float dots = 20.0;\n    vec2 center = vec2(0, 0);\n\n    vec4 transition(vec2 uv) {\n        bool nextImage = distance(fract(uv * dots), vec2(0.5, 0.5)) < ( progress / distance(uv, center));\n        return nextImage ? getToColor(uv) : getFromColor(uv);\n    }\n`;\n","import './index.css'\n\nimport React from 'react'\nimport ReactDOM from 'react-dom'\nimport App from './App'\n\nReactDOM.render(<App />, document.getElementById('root'))\n","module.exports = __webpack_public_path__ + \"static/media/cat2.03e391d0.png\";","module.exports = __webpack_public_path__ + \"static/media/mask.4b652f63.png\";"],"sourceRoot":""}