{"version":3,"sources":["assets/img/cat3.jpg","../../src/transitions/blobby.glsl.js","../../src/ReactGlTransitionImage/index.jsx","../../src/transitions/mask.glsl.js","../../src/transitions/glitch.glsl.js","App.jsx","../../src/transitions/water.glsl.js","../../src/transitions/polka.glsl.js","index.js","assets/img/cat2.png","assets/img/mask.png"],"names":["module","exports","ReactGlTransitionImage","className","props","src","progress","onAssetsLoaded","style","transition","transitionAlpha","textures","mask","transitionSrc","textureUrls","reglInstance","React","canvasRef","reglReady","setReglReady","renderCalls","setRenderCalls","image","imageData","setImageData","dimRef","wrapDimensions","useResizeObserver","ref","seed","Math","mainImagePromise","Promise","resolve","texturePromises","textureImage","textureData","gl","alpha","antialias","stencil","preserveDrawingBuffer","_regl","regl","imageTexture","data","flipY","formattedTextures","textureResolutions","texture","drawImage","frag","vert","attributes","position","uniforms","resolution","imageResolution","blend","enable","func","srcRGB","srcAlpha","dstRGB","dstAlpha","depth","count","color","wrapperStyles","width","height","regularBgStyles","top","left","backgroundImage","backgroundSize","backgroundPosition","PropTypes","string","GlFadeInImage","useInView","threshold","triggerOnce","inView","useState","assetsLoaded","setAssetsLoaded","useCallback","active","config","tension","friction","clamp","to","fadeProgress","scale","yPos","animProps","transform","App","Array","map","_","i","key","cat2Src","cat3Src","maskSrc","ReactDOM","render","document","getElementById"],"mappings":"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","file":"static/js/main.8f61bd08.chunk.js","sourcesContent":["module.exports = __webpack_public_path__ + \"static/media/cat3.70aaec79.jpg\";","export default `\n    // https://gist.github.com/patriciogonzalezvivo/670c22f3966e662d2f83\n\n    float rand(vec2 n) {\n        return fract(sin(dot(n, vec2(12.9898 + seed, 4.1414))) * 43758.5453);\n    }\n\n    float noise(vec2 p) {\n        vec2 ip = floor(p);\n        vec2 u = fract(p);\n\n        u = u*u*(3.0-2.0*u);\n\n        float res = mix(\n            mix(rand(ip),rand(ip+vec2(1.0,0.0)),u.x),\n            mix(rand(ip+vec2(0.0,1.0)),rand(ip+vec2(1.0,1.0)),u.x),\n            u.y\n        );\n\n        return res*res;\n    }\n\n    vec4 transition(vec2 uv) {\n        vec4 col = getToColor(uv);\n\n        // generate blobby noise mask\n        float mask = pow(smoothstep(0.1, 1., clamp(noise(uv*4.) + noise(uv*3.5), 0.2, 1.)), 2.);\n        vec4 maskCol = vec4(vec3(mask), 1.);\n\n        // white => transparent\n        maskCol.a = (maskCol.r + maskCol.g + maskCol.b)/3.;\n\n        // debug mask\n        // return maskCol;\n\n        return mix(\n            vec4(0.),\n            col - ((col*0.1+vec4(vec3(0.1), 0.)) - (maskCol * ((1./progress))))\n                * (1. - (1./progress)) * 4.,\n            progress\n        );\n    }\n`;\n","import React from 'react';\nimport PropTypes from 'prop-types';\n\nimport _regl from 'regl';\nimport useResizeObserver from 'use-resize-observer';\n\nimport blobbyTransition from '../transitions/blobby.glsl';\nimport maskTransition from '../transitions/mask.glsl';\n\nconst ReactGlTransitionImage = React.forwardRef((props, ref) => {\n    const {\n        className,\n        src,\n        progress,\n        onAssetsLoaded,\n        style,\n        transition,\n        transitionAlpha,\n        textures,\n        mask,\n    } = props;\n\n    const transitionSrc = mask\n        ? maskTransition\n        : transition;\n\n    const textureUrls = React.useMemo(() => (\n        mask\n            ? [...textures, mask]\n            : textures\n    ), [mask, textures]);\n\n    const reglInstance = React.useRef(null);\n    const canvasRef = React.useRef(null);\n\n    const [reglReady, setReglReady] = React.useState(false);\n    const [renderCalls, setRenderCalls] = React.useState(null);\n    const [imageData, setImageData] = React.useState({\n        image: null,\n        textures: [],\n    });\n\n    const dimRef = React.useRef(null);\n    const wrapDimensions = useResizeObserver({ ref: dimRef });\n\n    const seed = React.useMemo(() => Math.random() * 1000, []);\n\n    // load image & optional texture data\n\n    React.useEffect(() => {\n        (async () => {\n            const mainImagePromise = new Promise((resolve) => {\n                const image = new Image();\n                image.onload = () => {\n                    resolve(image);\n                };\n\n                image.src = src;\n            });\n\n            let texturePromises = [];\n            if (textureUrls.length > 0) {\n                texturePromises = textureUrls.map((texture) => new Promise((resolve) => {\n                    const textureImage = new Image();\n                    textureImage.onload = () => {\n                        resolve(textureImage);\n                    };\n\n                    textureImage.src = texture;\n                }));\n            }\n\n            const [image, ...textureData] = await Promise.all([\n                mainImagePromise,\n                ...texturePromises,\n            ]);\n\n            setImageData({\n                image,\n                textures: textureData,\n            });\n\n            onAssetsLoaded();\n        })();\n    }, [src, textureUrls, onAssetsLoaded]);\n\n    // construct regl instance (& webgl context) once progress > 0\n    // (otherwise, having many images, we'll hit the max amount of simultaneous gl contexts)\n\n    React.useEffect(() => {\n        if (reglReady || !imageData.image\n            || progress === 0 || progress >= 1) {\n            return;\n        }\n\n        const gl = canvasRef.current.getContext('webgl', {\n            alpha: true,\n            antialias: true,\n            stencil: false,\n            preserveDrawingBuffer: false,\n        });\n\n        reglInstance.current = _regl({ gl });\n        setReglReady(true);\n    }, [reglReady, imageData, progress]);\n\n    // construct regl draw calls\n\n    React.useEffect(() => {\n        if (!reglReady || !imageData.image) {\n            return;\n        }\n\n        const regl = reglInstance.current;\n\n        const imageTexture = regl.texture({\n            data: imageData.image,\n            flipY: true,\n        });\n\n        const formattedTextures = imageData.textures\n            .reduce((texObj, texture, i) => ({\n                ...texObj,\n                [`textures[${i}]`]: regl.texture({\n                    data: texture,\n                    flipY: true,\n                }),\n            }), {});\n\n        const textureResolutions = imageData.textures\n            .reduce((resObj, texture, i) => ({\n                ...resObj,\n                [`textureResolutions[${i}]`]: [\n                    texture.width,\n                    texture.height,\n                ],\n            }), {});\n\n        const drawImage = regl({\n            frag: `\n                precision highp float;\n\n                uniform sampler2D image;\n                uniform vec2 resolution;\n                uniform vec2 imageResolution;\n                uniform float progress, seed;\n\n                ${imageData.textures.length > 0 ? `\n                    uniform sampler2D textures[${imageData.textures.length}];\n                    uniform vec2 textureResolutions[${imageData.textures.length}];\n                ` : ''}\n\n                varying vec2 uv;\n\n                // draw image using \"background-size: cover\"-ish fill\n                // https://gist.github.com/statico/df64c5d167362ecf7b34fca0b1459a44\n                vec2 convertToCoverUvs(vec2 uv, vec2 imageRes) {\n                    vec2 s = resolution; // screen\n                    vec2 i = imageRes; // image\n\n                    float rs = s.x / s.y;\n                    float ri = i.x / i.y;\n\n                    vec2 new = rs < ri\n                        ? vec2(i.x * s.y / i.y, s.y)\n                        : vec2(s.x, i.y * s.x / i.x);\n\n                    vec2 offset = rs < ri\n                        ? vec2((new.x - s.x) / 2.0, 0.0) / new\n                        : vec2(0.0, (new.y - s.y) / 2.0) / new;\n\n                    vec2 uw = uv * s / new + offset;\n\n                    return uw;\n                }\n\n                vec4 getFromColor(vec2 st) {\n                    return vec4(0.);\n                }\n\n                vec4 getToColor(vec2 uv) {\n                    vec2 uw = convertToCoverUvs(uv, imageResolution);\n                    return texture2D(image, uw);\n                }\n\n                ${transitionSrc}\n\n                void main () {\n                    gl_FragColor = transition(uv);\n                    ${transitionAlpha ? 'gl_FragColor.a = progress;' : ''}\n                }\n            `,\n            vert: `\n                precision highp float;\n\n                attribute vec2 position;\n                uniform vec2 resolution;\n                varying vec2 uv;\n\n                void main () {\n                    uv = 1. - position;\n                    gl_Position = vec4(1.0 - 2.0 * position, 0, 1);\n                }\n            `,\n            attributes: {\n                position: [\n                    -2, 0,\n                    0, -2,\n                    2, 2,\n                ],\n            },\n            uniforms: {\n                progress: regl.prop('progress'),\n                resolution: regl.prop('resolution'),\n                seed,\n                image: imageTexture,\n                imageResolution: [\n                    imageData.image.width,\n                    imageData.image.height,\n                ],\n                ...textureResolutions,\n                ...formattedTextures,\n            },\n            // https://stackoverflow.com/questions/45066688/blending-anti-aliased-circles-with-regl/45071910#45071910\n            blend: {\n                enable: true,\n                func: {\n                    srcRGB: 'src alpha',\n                    srcAlpha: 'src alpha',\n                    dstRGB: 'one minus src alpha',\n                    dstAlpha: 'one minus src alpha',\n                },\n            },\n            depth: { enable: false },\n            count: 3,\n        });\n\n        setRenderCalls({ drawImage });\n    }, [reglReady, imageData, seed, transitionAlpha, transitionSrc]);\n\n    // render\n\n    React.useEffect(() => {\n        if (!reglReady || !renderCalls || progress === 0) {\n            return;\n        }\n\n        const regl = reglInstance.current;\n\n        regl.clear({\n            color: [0, 0, 0, 0],\n            depth: 1,\n        });\n\n        renderCalls.drawImage({\n            progress,\n            resolution: [\n                wrapDimensions.width,\n                wrapDimensions.height,\n            ],\n        });\n\n        if (regl && progress >= 1) {\n            regl.destroy();\n            reglInstance.current = null;\n            setReglReady(false);\n        }\n    }, [reglReady, renderCalls, progress, wrapDimensions]);\n\n    // styles\n\n    const wrapperStyles = {\n        position: 'relative',\n        width: '100%',\n        height: '100%',\n        ...style,\n    };\n\n    const canvasWrapperStyles = {\n        position: 'absolute',\n        top: '0',\n        left: '0',\n        width: '100%',\n        height: '100%',\n    };\n\n    const regularBgStyles = {\n        position: 'absolute',\n        top: '0',\n        left: '0',\n\n        width: '100%',\n        height: '100%',\n\n        backgroundImage: `url('${src}')`,\n        backgroundSize: 'cover',\n        backgroundPosition: 'center',\n    };\n\n    return (\n        <div\n            className={className}\n            style={wrapperStyles}\n            ref={dimRef}\n        >\n            {progress <= 1 && (\n                <div\n                    ref={ref}\n                    style={canvasWrapperStyles}\n                >\n                    <canvas\n                        ref={canvasRef}\n                        width={wrapDimensions.width}\n                        height={wrapDimensions.height}\n                    />\n                </div>\n            )}\n            {progress >= 1 && (\n                <div\n                    style={regularBgStyles}\n                />\n            )}\n        </div>\n    );\n});\n\nReactGlTransitionImage.propTypes = {\n    src: PropTypes.string.isRequired,\n    progress: PropTypes.number.isRequired,\n    onAssetsLoaded: PropTypes.func,\n    className: PropTypes.string,\n    style: PropTypes.objectOf(PropTypes.string),\n    transition: PropTypes.string,\n    transitionAlpha: PropTypes.bool,\n    textures: PropTypes.arrayOf(PropTypes.string),\n    mask: PropTypes.string,\n};\n\nReactGlTransitionImage.defaultProps = {\n    className: '',\n    style: {},\n    onAssetsLoaded: () => {},\n    transition: blobbyTransition,\n    transitionAlpha: false,\n    textures: [],\n    mask: null,\n};\n\nexport default ReactGlTransitionImage;\n","// rand() & noise() from:\n// https://gist.github.com/patriciogonzalezvivo/670c22f3966e662d2f83\n\nexport default `\n    float rand(vec2 n) {\n        return fract(sin(dot(n, vec2(12.9898 + seed, 4.1414))) * 43758.5453);\n    }\n\n    float noise(vec2 p) {\n        vec2 ip = floor(p);\n        vec2 u = fract(p);\n\n        u = u*u*(3.0-2.0*u);\n\n        float res = mix(\n            mix(rand(ip),rand(ip+vec2(1.0,0.0)),u.x),\n            mix(rand(ip+vec2(0.0,1.0)),rand(ip+vec2(1.0,1.0)),u.x),\n            u.y\n        );\n\n        return res*res;\n    }\n\n    vec4 getMaskColor(vec2 uv) {\n        vec2 uw = convertToCoverUvs(uv, textureResolutions[0]);\n        return texture2D(textures[0], uw);\n    }\n\n    vec4 transition(vec2 uv) {\n        vec4 col = getToColor(uv);\n        vec4 maskCol = getMaskColor(uv);\n\n        // white => transparent\n        maskCol.a = (maskCol.r + maskCol.g + maskCol.b)/3.;\n\n        // debug mask\n        // return maskCol;\n\n        return mix(\n            vec4(0.),\n\n            col - ((col*0.1+vec4(vec3(0.1), 0.)) - (maskCol * ((1./progress))))\n                * (1. - (1./progress)) * 4.,\n\n            progress\n        );\n    }\n`;\n","// author: Gunnar Roth\n// based on work from natewave\n// adapted by Jakob Stasilowicz\n// license: MIT\n\nexport default `\n    vec4 transition(vec2 p) {\n        vec2 block = floor(p.xy / vec2(16));\n        vec2 uv_noise = block / vec2(64);\n        uv_noise += floor(vec2(progress) * vec2(1200.0, 3500.0)) / vec2(64);\n        vec2 dist = progress > 0.0 ? (fract(uv_noise) - 0.5) * 0.3 *(1.0 -progress) : vec2(0.0);\n\n        vec2 red = p + dist * 0.2;\n        vec2 green = p + dist * .3;\n        vec2 blue = p + dist * .5;\n\n        return vec4(\n            getToColor(red).r,\n            getToColor(green).g,\n            getToColor(blue).b,\n            1.0\n        );\n    }\n`;\n","import React from 'react';\n\nimport ReactGlTransitionImage, {\n    glitchTransition,\n    polkaTransition,\n    noiseSwirlsTransition,\n    blurTransition,\n    waterTransition,\n} from 'react-gl-transition-image';\n\nimport { useInView } from 'react-intersection-observer';\nimport { Spring } from 'react-spring/renderprops';\n\nimport './index.css';\n\nimport cat2Src from './assets/img/cat2.png';\nimport cat3Src from './assets/img/cat3.jpg';\nimport maskSrc from './assets/img/mask.png';\n\nconst GlFadeInImage = ({ src, textures, mask, transition }) => {\n    const [ref, inView] = useInView({\n        threshold: 0,\n        triggerOnce: true\n    });\n\n    const [assetsLoaded, setAssetsLoaded] = React.useState(false);\n    const onAssetsLoaded = React.useCallback(() => setAssetsLoaded(true), [setAssetsLoaded]);\n\n    const active = inView && assetsLoaded;\n\n    return (\n        <div className=\"image\">\n            <Spring\n                config={{\n                    tension: 180,\n                    friction: 45,\n                    clamp: true\n                }}\n                to={{\n                    fadeProgress: active ? 1 : 0,\n                    scale: active ? 1 : 0.9,\n                    yPos: active ? 0 : 80\n                }}\n            >\n                {animProps =>\n                    <ReactGlTransitionImage\n                        ref={ref}\n                        src={src}\n                        onAssetsLoaded={onAssetsLoaded}\n\n                        mask={mask}\n                        textures={textures}\n                        transition={transition}\n\n                        progress={animProps.fadeProgress}\n                        style={{\n                            transform: `scale(${animProps.scale}) translate3d(0, ${animProps.yPos}px, 0)`\n                        }}\n                    />\n                }\n            </Spring>\n        </div>\n    );\n};\n\nconst App = () => {\n    return (\n        <>\n            {[...Array(2)].map((_, i) =>\n                <div\n                    className=\"wrapper\"\n                    key={i}\n                >\n                    <h2>Default transition</h2>\n                    <GlFadeInImage\n                        src={cat2Src}\n                    />\n\n                    <h2>Water</h2>\n                    <GlFadeInImage\n                        src={cat3Src}\n                        transition={waterTransition}\n                    />\n\n                    <h2>Blur</h2>\n                    <GlFadeInImage\n                        src={cat3Src}\n                        transition={blurTransition}\n                    />\n\n                    <h2>Image mask</h2>\n                    <GlFadeInImage\n                        src={cat3Src}\n                        mask={maskSrc}\n                    />\n\n                    <h2>Glitch</h2>\n                    <GlFadeInImage\n                        src={cat2Src}\n                        transition={glitchTransition}\n                    />\n\n                    <h2>Polka</h2>\n                    <GlFadeInImage\n                        src={cat3Src}\n                        transition={polkaTransition}\n                    />\n\n                    <h2>Noise swirl</h2>\n                    <GlFadeInImage\n                        src={cat2Src}\n                        transition={noiseSwirlsTransition}\n                    />\n                </div>\n            )}\n        </>\n    );\n}\n\nexport default App;\n","// original author: Paweł Płóciennik\n// adapted by: Jakob Stasilowicz\n// license: MIT\n\nexport default `\n    const float amplitude = 30.;\n    const float speed = 10.;\n\n    vec4 transition(vec2 p) {\n        vec2 dir = p - vec2(.5);\n        float dist = length(dir);\n\n        if (dist > progress) {\n            return vec4(0.);\n        } else {\n            vec2 offset = dir * sin(dist * amplitude - progress * speed);\n            return getToColor( p + (offset * (1. - 1./progress)) );\n        }\n    }\n`;\n","// original author: bobylito\n// license: MIT\n\nexport default `\n    const float SQRT_2 = 1.414213562373;\n\n    float dots = 20.0;\n    vec2 center = vec2(0, 0);\n\n    vec4 transition(vec2 uv) {\n        bool nextImage = distance(fract(uv * dots), vec2(0.5, 0.5)) < ( progress / distance(uv, center));\n        return nextImage ? getToColor(uv) : getFromColor(uv);\n    }\n`;\n","import './index.css'\n\nimport React from 'react'\nimport ReactDOM from 'react-dom'\nimport App from './App'\n\nReactDOM.render(<App />, document.getElementById('root'))\n","module.exports = __webpack_public_path__ + \"static/media/cat2.03e391d0.png\";","module.exports = __webpack_public_path__ + \"static/media/mask.4b652f63.png\";"],"sourceRoot":""}